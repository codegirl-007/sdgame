<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Design Canvas Game</title>
    <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      display: flex;
      height: 100vh;
      font-family: 'Fira Code', monospace;
      background-color: #1e1e1e;
      color: #ccc;
    }

    #sidebar {
      width: 280px;
      background-color: #111;
      border-right: 1px solid #333;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
    }

    .component-icon, #arrow-tool {
      padding: 10px 12px;
      background-color: #1e1e1e;
      border: 1px solid #444;
      border-radius: 4px;
      text-align: center;
      cursor: grab;
      user-select: none;
      font-size: 13px;
      transition: background-color 0.1s ease;
      color: #eee;
    }

    .component-icon:hover, #arrow-tool:hover {
      background-color: #2a2a2a;
    }

    .component-icon:active, #arrow-tool:active {
      cursor: grabbing;
    }

    #arrow-tool.active {
      background-color: #005f87;
      color: white;
      border-color: #007acc;
    }

    #canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background-color: #202020;
    }

    #canvas {
      width: 100%;
      height: 100%;
    }

    .dropped {
      cursor: move;
    }

    .dropped.selected rect {
      stroke: #00bcd4;
      stroke-width: 2;
    }

    #run-button {
      margin-top: auto;
      padding: 10px;
      background-color: #007acc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    #run-button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }

    #node-props-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 220px;
      background-color: #111;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 12px;
      color: #eee;
      box-shadow: 0 0 10px rgba(0,0,0,0.6);
      display: none;
      z-index: 10;
    }

    #node-props-panel h3 {
      margin-top: 0;
      font-size: 15px;
      color: #ccc;
    }

    .prop-group {
      display: none;
      margin-bottom: 12px;
    }

    .prop-group label, .prop-group input {
      display: block;
      width: 100%;
      margin-top: 6px;
      font-size: 13px;
    }

    input[type="text"],
    input[type="number"] {
      padding: 6px;
      background-color: #222;
      border: 1px solid #555;
      color: #eee;
      border-radius: 4px;
      font-family: 'Fira Code', monospace;
    }

    #node-props-panel button {
      padding: 8px;
      background-color: #007acc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 8px;
    }

    #node-props-panel button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }

    #info-panel {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: #121212;
      color: #ccc;
      padding: 1rem;
      border-radius: 8px;
      font-family: monospace;
      font-size: 14px;
      min-width: 220px;
      z-index: 10;
      border: 1px solid #333;
      box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
    }

    #constraints-panel,
    #score-panel {
      margin-bottom: 1rem;
    }

    .panel-title {
      font-weight: bold;
      color: #fff;
      font-size: 15px;
      margin-bottom: 0.5rem;
    }

    .panel-metric {
      margin-bottom: 0.4rem;
    }

    .panel-metric .label {
      display: inline-block;
      width: 140px;
      color: #888;
    }

    .component-icon {
      position: relative;
      padding: 8px;
      margin-bottom: 6px;
      background: #1e1e1e;
      color: white;
      border: 1px solid #444;
      border-radius: 6px;
      cursor: grab;
    }

    .component-icon .tooltip {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      top: 100%;
      left: 0;
      z-index: 10;
      background: #333;
      color: #fff;
      padding: 6px 8px;
      border-radius: 4px;
      white-space: nowrap;
      font-size: 12px;
      line-height: 1.4;
      margin-top: 4px;
      transition: opacity 0.2s;
    }

    .component-icon:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    .component-icon.dragging .tooltip {
  display: none;
}

    </style>
  </head>
  <body>
    <div id="info-panel">
      <div id="constraints-panel">
        <div class="panel-title">Level Constraints</div>
        <div class="panel-metric"><span class="label">üéØ Target RPS:</span> <span id="constraint-rps">‚Äì</span></div>
        <div class="panel-metric"><span class="label">‚è±Ô∏è Max P95 Latency:</span> <span id="constraint-latency">‚Äì</span></div>
        <div class="panel-metric"><span class="label">üí∏ Max Cost:</span> <span id="constraint-cost">‚Äì</span></div>
        <div class="panel-metric"><span class="label">üîí Availability:</span> <span id="constraint-availability">‚Äì</span></div>
      </div>

      <div id="score-panel">
        <div class="panel-title">Simulation Results</div>
        <div class="panel-metric"><span class="label">‚úÖ Cost:</span> <span id="score-cost">‚Äì</span></div>
        <div class="panel-metric"><span class="label">‚ö° P95 Latency:</span> <span id="score-p95">‚Äì</span></div>
        <div class="panel-metric"><span class="label">üìà Achieved RPS:</span> <span id="score-rps">‚Äì</span></div>
        <div class="panel-metric"><span class="label">üõ°Ô∏è Availability:</span> <span id="score-availability">‚Äì</span></div>
      </div>
    </div>
    <div id="sidebar">
      <div class="component-icon" draggable="true" data-type="Client">
        Client/User
        <span class="tooltip">Simulates user traffic</span>
      </div>

      <div class="component-icon" draggable="true" data-type="LoadBalancer">
        Load Balancer
        <span class="tooltip">Cost: $5/mo<br>Distributes traffic evenly<br>Latency: 5 ms</span>
      </div>

      <div class="component-icon" draggable="true" data-type="WebServerSmall">
        Web Server (Small)
        <span class="tooltip">Cost: $10/mo<br>Capacity: 100 RPS<br>Base Latency: 50 ms</span>
      </div>

      <div class="component-icon" draggable="true" data-type="WebServerMedium">
        Web Server (Medium)
        <span class="tooltip">Cost: $20/mo<br>Capacity: 200 RPS<br>Base Latency: 40 ms</span>
      </div>

      <div class="component-icon" draggable="true" data-type="Database">
        Database
        <span class="tooltip">Cost: $20/mo<br>Read Capacity: 150 RPS<br>Base Latency: 80 ms<br>Supports replication</span>
      </div>

      <div class="component-icon" draggable="true" data-type="CacheStandard">
        Cache (Standard)
        <span class="tooltip">Cost: $10/mo<br>Capacity: 100 RPS<br>Latency: 5 ms<br>80% hit rate with 1hr TTL</span>
      </div>

      <div class="component-icon" draggable="true" data-type="CacheLarge">
        Cache (Large)
        <span class="tooltip">Cost: $20/mo<br>Capacity: 200 RPS<br>Latency: 5 ms<br>Higher hit rate for large datasets</span>
      </div>

      <div class="component-icon" draggable="true" data-type="MessageQueue">
        Message Queue
        <span class="tooltip">Cost: $15/mo<br>Decouples components<br>Useful for batching writes</span>
      </div>

      <div class="component-icon" draggable="true" data-type="CDN">
        CDN/Edge Cache
        <span class="tooltip">Cost: $0.03/GB<br>Improves global latency<br>Caches static content</span>
      </div>

      <div class="component-icon" draggable="true" data-type="Microservice">
        Microservice Node
        <span class="tooltip">Cost: $10/mo<br>Stateless container<br>Use for modular logic</span>
      </div>

      <div class="component-icon" draggable="true" data-type="DataPipeline">
        Data Pipeline
        <span class="tooltip">Cost: $25/mo<br>Stream or batch processing<br>Used for analytics / ETL</span>
      </div>

      <div class="component-icon" draggable="true" data-type="Monitoring">
        Monitoring/Alerting
        <span class="tooltip">Cost: $5/mo<br>Health checks + logs<br>Alerts on failures</span>
      </div>

      <div class="component-icon" draggable="true" data-type="ThirdParty">
        Third-Party Service
        <span class="tooltip">External APIs<br>Latency + cost vary<br>Examples: Payment, Email, Search</span>
      </div>

      <div id="arrow-tool">Arrow Tool</div>
      <button id="run-button" disabled>Run Simulation</button>
    </div>

    <div id="canvas-container">
      <svg id="canvas">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#333" />
          </marker>
        </defs>
      </svg>
      <div id="node-props-panel">
        <h3>Node Properties</h3>
        <div id="label-group">
          <label>Label:<input type="text" name="label" /></label>
        </div>
        <div id="db-group" class="prop-group">
          <label>Replication Factor:<input type="number" name="replication" min="1" step="1" /></label>
        </div>
        <div id="cache-group" class="prop-group">
          <label>Cache TTL (secs):<input type="number" name="cacheTTL" min="0" step="60" /></label>
        </div>
        <button id="node-props-save" disabled>Save</button>
      </div>
    </div>

    <script>
    let nodeIdCounter = 1;
    function generateNodeId() {
      return `node-${nodeIdCounter++}`;
    }

    function createSVGElement(tag, attrs) {
      const elem = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (let key in attrs) {
        elem.setAttribute(key, attrs[key]);
      }
      return elem;
    }

    class Node {
      constructor(type, x, y, app) {
        this.id = generateNodeId();
        this.type = type;
        this.app = app;
        this.props = {
          label: type,
          replication: 1,
          cacheTTL: 0
        };
        this.group = createSVGElement('g', { class: 'dropped', 'data-type': type });
        const rect = createSVGElement('rect', {
          x, y,
          width: 0,
          height: app.componentSize.height,
          fill: '#e0e0e0',
          stroke: '#333',
          'stroke-width': 1,
          rx: 4, ry: 4
        });
        this.group.appendChild(rect);
        this.text = createSVGElement('text', {
          x: x + app.componentSize.width / 2,
          y: y + app.componentSize.height / 2 + 5,
          'text-anchor': 'middle',
          'font-size': 14,
          fill: '#000'
        });
        this.text.textContent = this.props.label;
        this.app.canvas.appendChild(this.text); // temporarily append to measure
        const textWidth = this.text.getBBox().width;
        const padding = 20;
        const finalWidth = textWidth + padding;

        rect.setAttribute('width', finalWidth);
        this.text.setAttribute('x', x + finalWidth / 2);
        this.group.appendChild(this.text);
        this.group.__nodeObj = this;
        this.initDrag();
        this.group.addEventListener('click', (e) => {
          e.stopPropagation();
          if (app.arrowMode) {
            app.handleConnectionClick(this);
          } else {
            app.clearSelection();
            this.select();
            app.showPropsPanel(this);
          }
        });
        app.canvas.appendChild(this.group);
        app.placedComponents.push(this);
        app.runButton.disabled = false;
      }

      initDrag() {
        this.id = generateNodeId();
        let offsetX, offsetY;

        const onMouseMove = (e) => {
          const pt = this.app.canvas.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(this.app.canvas.getScreenCTM().inverse());

          const newX = svgP.x - offsetX;
          const newY = svgP.y - offsetY;

          this.group.setAttribute('transform', `translate(${newX}, ${newY})`);

          this.app.connections.forEach(conn => {
            if (conn.start === this || conn.end === this) {
              conn.updatePosition();
            }
          });
        };

        const onMouseUp = () => {
          window.removeEventListener('mousemove', onMouseMove);
          window.removeEventListener('mouseup', onMouseUp);
        };

        this.group.addEventListener('mousedown', (e) => {
          e.preventDefault();
          const pt = this.app.canvas.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(this.app.canvas.getScreenCTM().inverse());

          const ctm = this.group.getCTM();
          offsetX = svgP.x - ctm.e;
          offsetY = svgP.y - ctm.f;

          window.addEventListener('mousemove', onMouseMove);
          window.addEventListener('mouseup', onMouseUp);
        });        
      }

      updateLabel(newLabel) {
        this.props.label = newLabel;
        this.text.textContent = newLabel;
        const textWidth = this.text.getBBox().width;
        const padding = 20;
        const finalWidth = textWidth + padding;

        this.group.querySelector('rect').setAttribute('width', finalWidth);
        this.text.setAttribute('x', parseFloat(this.group.querySelector('rect').getAttribute('x')) + finalWidth / 2);

      }

      getCenter() {
        const bbox = this.group.getBBox();
        const ctm = this.group.getCTM();
        const x = ctm.e + bbox.x + bbox.width / 2;
        const y = ctm.f + bbox.y + bbox.height / 2;
        return { x, y };
      }

      select() {
        this.app.clearSelection();
        this.group.classList.add('selected');
        this.app.selectedNode = this;
      }

      deselect() {
        this.group.classList.remove('selected');
        if (this.app.selectedNode === this) {
          this.app.selectedNode = null;
        }
      }
    }

    class Connection {
      constructor(startNode, endNode, label, app) {
        this.start = startNode;
        this.end = endNode;
        this.app = app;
        this.line = createSVGElement('line', {
          stroke: '#333', 'stroke-width': 2, 'marker-end': 'url(#arrowhead)'
        });
        this.text = createSVGElement('text', {
          'text-anchor': 'middle', 'font-size': 12, fill: '#333'
        });
        this.text.textContent = label;
        app.canvas.appendChild(this.line);
        app.canvas.appendChild(this.text);
        this.updatePosition();

        this.selected = false;
        this.line.addEventListener('click', (e) => {
          e.stopPropagation();
          this.app.clearSelection();
          this.select();
        });
      }

      updatePosition() {
        const s = this.start.getCenter();
        const e = this.end.getCenter();
        this.line.setAttribute('x1', s.x);
        this.line.setAttribute('y1', s.y);
        this.line.setAttribute('x2', e.x);
        this.line.setAttribute('y2', e.y);
        const midX = (s.x + e.x) / 2;
        const midY = (s.y + e.y) / 2;
        this.text.setAttribute('x', midX);
        this.text.setAttribute('y', midY - 5);
      }

      select() {
        this.app.clearSelection();
        this.selected = true;
        this.line.setAttribute('stroke', '#007bff');
        this.line.setAttribute('stroke-width', 3);
        this.app.selectedConnection = this;
      }

      deselect() {
        this.selected = false;
        this.line.setAttribute('stroke', '#333');
        this.line.setAttribute('stroke-width', 2);
      }
    }

    class CanvasApp {
      constructor() {
        this.placedComponents = [];
        this.connections = [];
        this.componentSize = { width: 120, height: 40 };
        this.arrowMode = false;
        this.connectionStart = null;
        this.activeNode = null;
        this.selectedConnection = null;

        this.sidebar = document.getElementById('sidebar');
        this.arrowTool = document.getElementById('arrow-tool');
        this.canvasContainer = document.getElementById('canvas-container');
        this.canvas = document.getElementById('canvas');
        this.runButton = document.getElementById('run-button');
        this.nodePropsPanel = document.getElementById('node-props-panel');
        this.propsSaveBtn = document.getElementById('node-props-save');
        this.labelGroup = document.getElementById('label-group');
        this.dbGroup = document.getElementById('db-group');
        this.cacheGroup = document.getElementById('cache-group');
        this.selectedNode = null;

        this.initEventHandlers();
      }

      initEventHandlers() {
        this.arrowTool.addEventListener('click', () => {
          this.arrowMode = !this.arrowMode;
          if (this.arrowMode) {
            this.arrowTool.classList.add('active');
            this.hidePropsPanel();
          } else {
            this.arrowTool.classList.remove('active');
            if (this.connectionStart) {
              this.connectionStart.group.classList.remove('selected');
              this.connectionStart = null;
            }
          }
        });

        this.sidebar.addEventListener('dragstart', (e) => {
          if (e.target.classList.contains('component-icon')) {
            e.dataTransfer.setData('text/plain', e.target.getAttribute('data-type'));
            e.target.classList.add('dragging');
          }
        });
        this.sidebar.addEventListener('dragend', (e) => {
  if (e.target.classList.contains('component-icon')) {
    e.target.classList.remove('dragging');
  }
});

        this.canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
        this.canvasContainer.addEventListener('drop', (e) => {
          e.preventDefault();
          const type = e.dataTransfer.getData('text/plain');
          const pt = this.canvas.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(this.canvas.getScreenCTM().inverse());
          const x = svgP.x - this.componentSize.width / 2;
          const y = svgP.y - this.componentSize.height / 2;
          new Node(type, x, y, this);
        });

        this.runButton.addEventListener('click', () => {
          const designData = this.exportDesign();
          alert(JSON.stringify(designData));
        });

        this.canvas.addEventListener('click', () => {
          if (this.connectionStart) {
            this.connectionStart.group.classList.remove('selected');
            this.connectionStart = null;
          }
          this.hidePropsPanel();
          this.clearSelection();
        });

        this.propsSaveBtn.addEventListener('click', () => {
          if (!this.activeNode) return;
          const nodeObj = this.activeNode;
          const panel = this.nodePropsPanel;
          const newLabel = panel.querySelector("input[name='label']").value;
          nodeObj.updateLabel(newLabel);
          if (nodeObj.type === 'Database') {
            nodeObj.props.replication = parseInt(panel.querySelector("input[name='replication']").value, 10);
          }
          if (nodeObj.type === 'CacheStandard' || nodeObj.type === 'CacheLarge') {
            nodeObj.props.cacheTTL = parseInt(panel.querySelector("input[name='cacheTTL']").value, 10);
          }
          this.hidePropsPanel();
        });

        document.addEventListener('keydown', (e) => {
          if (e.key === 'Backspace' || e.key === 'Delete') {
            if (this.selectedConnection) {
              this.canvas.removeChild(this.selectedConnection.line);
              this.canvas.removeChild(this.selectedConnection.text);
              const index = this.connections.indexOf(this.selectedConnection);
              if (index !== -1) this.connections.splice(index, 1);
              this.selectedConnection = null;
            } else if (this.selectedNode) {
              this.canvas.removeChild(this.selectedNode.group);
              this.placedComponents = this.placedComponents.filter(n => n !== this.selectedNode);
              this.connections = this.connections.filter(conn => {
                if (conn.start === this.selectedNode || conn.end === this.selectedNode) {
                  this.canvas.removeChild(conn.line);
                  this.canvas.removeChild(conn.text);
                  return false;
                }
                return true;
              });
              this.selectedNode = null;
              this.activeNode = null;
              this.hidePropsPanel();
            }
          }
        });
      }

      handleConnectionClick(nodeObj) {
        if (!this.connectionStart) {
          this.connectionStart = nodeObj;
          nodeObj.group.classList.add('selected');
        } else if (this.connectionStart === nodeObj) {
          this.connectionStart.group.classList.remove('selected');
          this.connectionStart = null;
        } else {
          const defaultLabel = 'Read traffic';
          const label = prompt('Enter connection label:', defaultLabel);
          if (label) {
            const conn = new Connection(this.connectionStart, nodeObj, label, this);
            this.connections.push(conn);
          }
          this.connectionStart.group.classList.remove('selected');
          this.connectionStart = null;
        }
      }

      showPropsPanel(nodeObj) {
        // ... unchanged ...
        this.activeNode = nodeObj;
        const panel = this.nodePropsPanel;

        // Position the panel (optional, or you can use fixed top/right)
        const bbox = nodeObj.group.getBBox();
        const ctm = nodeObj.group.getCTM();
        const screenX = ctm.e + bbox.x;
        const screenY = ctm.f + bbox.y + bbox.height;
        panel.style.left = (screenX + this.canvasContainer.getBoundingClientRect().left) + 'px';
        panel.style.top = (screenY + this.canvasContainer.getBoundingClientRect().top) + 'px';

        // Always show label group
        this.labelGroup.style.display = 'block';
        panel.querySelector("input[name='label']").value = nodeObj.props.label;

        // Show DB fields if it's a Database
        this.dbGroup.style.display = nodeObj.type === 'Database' ? 'block' : 'none';
        if (nodeObj.type === 'Database') {
          this.dbGroup.querySelector("input[name='replication']").value = nodeObj.props.replication;
        }

        // Show cache fields if it's a cache
        const isCache = nodeObj.type === 'CacheStandard' || nodeObj.type === 'CacheLarge';
        this.cacheGroup.style.display = isCache ? 'block' : 'none';
        if (isCache) {
          this.cacheGroup.querySelector("input[name='cacheTTL']").value = nodeObj.props.cacheTTL;
        }

        this.propsSaveBtn.disabled = false;
        panel.style.display = 'block';
      }

      hidePropsPanel() {
        this.nodePropsPanel.style.display = 'none';
        this.propsSaveBtn.disabled = true;
        this.activeNode = null;
      }

      updateConnectionsFor(movedNode) {
        this.connections.forEach(conn => {
          if (conn.start === movedNode || conn.end === movedNode) {
            conn.updatePosition();
          }
        });
      }

      clearSelection() {
        if (this.selectedConnection) {
          this.selectedConnection.deselect();
          this.selectedConnection = null;
        }

        if (this.selectedNode) {
          this.selectedNode.deselect();
          this.selectedNode = null;
          this.hidePropsPanel();
        }
      }

      exportDesign() {
        const nodes = this.placedComponents.map(n => ({
          id: n.id,
          type: n.type,
          x: n.x,
          y: n.y,
          props: n.props
        }));

        const connections = this.connections.map(c => ({
          source: c.start.id,
          target: c.end.id,
          label: c.label || ''
        }));

        return { nodes, connections };
      }
    }

    const app = new CanvasApp();
    </script>
  </body>
</html>

